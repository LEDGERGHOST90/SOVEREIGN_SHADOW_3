#!/usr/bin/env python3
"""
Manus Sync - Data Pipeline for Sovereign Shadow III
Handles data synchronization between Manus and the shared codebase.

This script:
1. Syncs analysis data to the shared repository
2. Creates proposals for data updates
3. Notifies other AIs of new data
4. Maintains the Manus state
"""

import json
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import shutil

# Configuration
BASE_DIR = Path(__file__).parent.parent
DATA_DIR = BASE_DIR / "data"
ANALYSIS_DIR = DATA_DIR / "analysis"
AI_DIR = BASE_DIR / ".ai"
STATE_FILE = AI_DIR / "state.json"

# Manus source directories (where Manus generates files)
MANUS_OUTPUT_DIR = Path("/home/ubuntu/crypto_analysis")

# Ensure directories exist
ANALYSIS_DIR.mkdir(parents=True, exist_ok=True)
(DATA_DIR / "prices").mkdir(parents=True, exist_ok=True)
(DATA_DIR / "opportunities").mkdir(parents=True, exist_ok=True)
(BASE_DIR / "reports").mkdir(parents=True, exist_ok=True)


class ManusSync:
    """Handles Manus data synchronization"""
    
    def __init__(self):
        self.state = self._load_state()
        self.timestamp = datetime.utcnow()
    
    def _load_state(self) -> Dict:
        """Load system state"""
        if STATE_FILE.exists():
            return json.loads(STATE_FILE.read_text())
        return {}
    
    def _save_state(self):
        """Save system state"""
        self.state["last_updated"] = self.timestamp.isoformat() + "Z"
        if "ai_agents" in self.state and "manus" in self.state["ai_agents"]:
            self.state["ai_agents"]["manus"]["last_active"] = self.timestamp.isoformat() + "Z"
            self.state["ai_agents"]["manus"]["status"] = "active"
        STATE_FILE.write_text(json.dumps(self.state, indent=2))
    
    def sync_analysis(self) -> Dict:
        """
        Sync latest analysis from Manus output directory to shared repo.
        Returns summary of synced files.
        """
        synced = {"files": [], "errors": []}
        date_str = self.timestamp.strftime("%Y-%m-%d")
        
        # Files to sync
        sync_map = {
            "ELITE_TOKEN_TRADING_REPORT.md": f"reports/analysis_{date_str}.md",
            "elite_token_opportunities.json": "data/opportunities/latest.json",
            "trading_opportunities.json": f"data/opportunities/opportunities_{date_str}.json",
        }
        
        for src_name, dst_path in sync_map.items():
            src = MANUS_OUTPUT_DIR / src_name
            dst = BASE_DIR / dst_path
            
            if src.exists():
                try:
                    dst.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(src, dst)
                    synced["files"].append({
                        "source": str(src),
                        "destination": str(dst),
                        "size": src.stat().st_size
                    })
                except Exception as e:
                    synced["errors"].append({
                        "file": str(src),
                        "error": str(e)
                    })
        
        # Also copy to README if it's the main report
        main_report = MANUS_OUTPUT_DIR / "ELITE_TOKEN_TRADING_REPORT.md"
        if main_report.exists():
            readme = BASE_DIR / "README.md"
            # Prepend header to README
            content = main_report.read_text()
            header = f"""# Sovereign Shadow III - Crypto Analysis

> **Last Updated**: {self.timestamp.strftime("%Y-%m-%d %H:%M UTC")}
> **Generated by**: Manus (Logistics Master)
> **Framework**: Unified AI Collaboration v1.0

---

"""
            readme.write_text(header + content)
            synced["files"].append({
                "source": str(main_report),
                "destination": str(readme),
                "note": "Updated README with latest analysis"
            })
        
        self._save_state()
        return synced
    
    def create_analysis_proposal(self, analysis_data: Dict) -> Dict:
        """
        Create a proposal for new analysis data.
        This allows other AIs to review before it's committed.
        """
        from ai_proposal_handler import ProposalHandler
        
        handler = ProposalHandler()
        
        # Prepare file changes
        files = [
            {
                "path": "data/opportunities/latest.json",
                "action": "update",
                "content": json.dumps(analysis_data, indent=2)
            }
        ]
        
        proposal = handler.create_proposal(
            ai_source="manus",
            proposal_type="analysis_update",
            description=f"Updated crypto analysis - {len(analysis_data.get('opportunities_ranked', []))} opportunities identified",
            files=files,
            rationale="Regular scheduled analysis update with latest market data",
            priority="medium"
        )
        
        return proposal
    
    def push_to_github(self, commit_message: Optional[str] = None) -> Dict:
        """
        Push synced data to GitHub repository.
        Returns result of git operations.
        """
        result = {"success": False, "output": [], "errors": []}
        
        if not commit_message:
            commit_message = f"[MANUS] Analysis sync {self.timestamp.strftime('%Y-%m-%d %H:%M')}"
        
        try:
            # Git operations
            commands = [
                ["git", "add", "-A"],
                ["git", "commit", "-m", commit_message],
                ["git", "push", "origin", "main"]
            ]
            
            for cmd in commands:
                proc = subprocess.run(
                    cmd,
                    cwd=BASE_DIR,
                    capture_output=True,
                    text=True
                )
                result["output"].append({
                    "command": " ".join(cmd),
                    "stdout": proc.stdout,
                    "stderr": proc.stderr,
                    "returncode": proc.returncode
                })
                
                if proc.returncode != 0 and "nothing to commit" not in proc.stdout:
                    result["errors"].append(proc.stderr)
            
            result["success"] = len(result["errors"]) == 0
            
        except Exception as e:
            result["errors"].append(str(e))
        
        return result
    
    def notify_team(self, event_type: str, summary: str) -> bool:
        """
        Notify other AIs about new data.
        Creates a notification in the shared state.
        """
        notification = {
            "id": f"notif_{self.timestamp.strftime('%Y%m%d_%H%M%S')}",
            "from": "manus",
            "type": event_type,
            "summary": summary,
            "timestamp": self.timestamp.isoformat() + "Z",
            "acknowledged_by": []
        }
        
        # Add to state notifications
        if "notifications" not in self.state:
            self.state["notifications"] = []
        
        self.state["notifications"].append(notification)
        
        # Keep only last 50 notifications
        self.state["notifications"] = self.state["notifications"][-50:]
        
        self._save_state()
        
        return True
    
    def get_sync_status(self) -> Dict:
        """Get current sync status"""
        return {
            "manus_output_dir": str(MANUS_OUTPUT_DIR),
            "target_dir": str(BASE_DIR),
            "last_sync": self.state.get("ai_agents", {}).get("manus", {}).get("last_active"),
            "files_available": [
                str(f.name) for f in MANUS_OUTPUT_DIR.glob("*") 
                if f.is_file() and not f.name.startswith(".")
            ] if MANUS_OUTPUT_DIR.exists() else []
        }


def main():
    """CLI interface for Manus sync"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Manus Data Sync")
    parser.add_argument("command", choices=["sync", "push", "status", "full"], 
                        help="Command to execute")
    parser.add_argument("--message", "-m", help="Commit message for push")
    
    args = parser.parse_args()
    sync = ManusSync()
    
    if args.command == "status":
        status = sync.get_sync_status()
        print(json.dumps(status, indent=2))
    
    elif args.command == "sync":
        result = sync.sync_analysis()
        print(f"\n{'='*60}")
        print("  MANUS SYNC COMPLETE")
        print(f"{'='*60}")
        print(f"\nFiles synced: {len(result['files'])}")
        for f in result["files"]:
            print(f"  ✓ {f['destination']}")
        if result["errors"]:
            print(f"\nErrors: {len(result['errors'])}")
            for e in result["errors"]:
                print(f"  ✗ {e}")
    
    elif args.command == "push":
        result = sync.push_to_github(args.message)
        print(f"\n{'='*60}")
        print("  GIT PUSH RESULT")
        print(f"{'='*60}")
        print(f"\nSuccess: {result['success']}")
        if result["errors"]:
            for e in result["errors"]:
                print(f"  Error: {e}")
    
    elif args.command == "full":
        # Full sync: sync files, then push to GitHub
        print("\n[1/3] Syncing analysis files...")
        sync_result = sync.sync_analysis()
        print(f"      Synced {len(sync_result['files'])} files")
        
        print("\n[2/3] Pushing to GitHub...")
        push_result = sync.push_to_github(args.message)
        print(f"      Push {'succeeded' if push_result['success'] else 'failed'}")
        
        print("\n[3/3] Notifying team...")
        sync.notify_team(
            "analysis_update",
            f"New analysis synced: {len(sync_result['files'])} files"
        )
        print("      Team notified")
        
        print(f"\n{'='*60}")
        print("  FULL SYNC COMPLETE")
        print(f"{'='*60}")


if __name__ == "__main__":
    main()
