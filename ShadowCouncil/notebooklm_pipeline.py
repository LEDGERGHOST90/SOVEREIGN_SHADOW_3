#!/usr/bin/env python3
"""
SOVEREIGN SHADOW COUNCIL - NotebookLM Pipeline

Automated pipeline for generating council content and preparing
for NotebookLM AI podcast generation.

Pipeline:
1. Refresh BRAIN.json with live exchange data
2. Generate council briefing with character dialogue
3. Combine with CryptoDex character guide
4. Output ready-to-upload package for NotebookLM

Usage:
    python3 ShadowCouncil/notebooklm_pipeline.py
    python3 ShadowCouncil/notebooklm_pipeline.py --open  # Opens NotebookLM in browser
"""

import os
import sys
import subprocess
import webbrowser
from datetime import datetime
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))
sys.path.insert(0, str(PROJECT_ROOT / "ShadowCouncil"))

from briefing_generator import BriefingGenerator


class NotebookLMPipeline:
    """
    Pipeline for NotebookLM integration.

    Generates content packages ready for NotebookLM upload.
    """

    NOTEBOOKLM_URL = "https://notebooklm.google.com/"

    def __init__(self):
        self.output_dir = PROJECT_ROOT / "daily_reports" / "notebooklm"
        self.output_dir.mkdir(parents=True, exist_ok=True)

        self.character_guide = PROJECT_ROOT / "ShadowCouncil" / "characters" / "CRYPTODEX_ASSET_PODCAST.md"
        self.briefing_generator = BriefingGenerator()

    def refresh_live_data(self) -> bool:
        """Run BRAIN.json refresh to get latest exchange data"""
        print("\n[1/4] Refreshing live exchange data...")

        refresh_script = PROJECT_ROOT / "scripts" / "refresh_brain.py"

        try:
            result = subprocess.run(
                [sys.executable, str(refresh_script)],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0:
                print("  ✅ Live data refreshed")
                return True
            else:
                print(f"  ⚠️  Refresh had issues: {result.stderr[:100]}")
                return False

        except Exception as e:
            print(f"  ❌ Refresh failed: {e}")
            return False

    def generate_briefing(self, emotion: str = "neutral", intensity: int = 5) -> str:
        """Generate council briefing with live data"""
        print("\n[2/4] Generating council briefing...")

        briefing = self.briefing_generator.generate_briefing(emotion, intensity)
        print("  ✅ Briefing generated")

        return briefing

    def create_notebooklm_package(self, briefing: str) -> Path:
        """
        Create a combined package for NotebookLM.

        Combines:
        - Character guide (personalities, voices)
        - Live briefing (current data, dialogue)
        """
        print("\n[3/4] Creating NotebookLM package...")

        timestamp = datetime.now().strftime("%Y-%m-%d_%H%M")
        output_file = self.output_dir / f"council_package_{timestamp}.md"

        # Read character guide
        with open(self.character_guide) as f:
            character_content = f.read()

        # Combine into single document
        package = f"""# SOVEREIGN SHADOW COUNCIL - COMPLETE PACKAGE
## For NotebookLM AI Podcast Generation
## Generated: {datetime.now().strftime("%Y-%m-%d %H:%M")}

---

# PART 1: CHARACTER GUIDE

{character_content}

---

# PART 2: TODAY'S LIVE BRIEFING

{briefing}

---

# PODCAST GENERATION PROMPTS

Use these prompts with NotebookLM to generate council debates:

## Quick Prompts:
1. "Generate a 5-minute podcast debate about today's portfolio status"
2. "Have The Elder and The Siren argue about the XRP position"
3. "Create a council meeting discussing whether to buy SOL"
4. "Generate a briefing where The Banker demands debt repayment"

## Deep Dive Prompts:
1. "Create a 10-minute analysis of the emotional trading patterns detected by The Mirror"
2. "Have all council members discuss the current allocation drift and what to do about it"
3. "Generate a heated debate between The Ghost (SOL) and The Siren (XRP) about portfolio priority"

## Character-Specific Prompts:
1. "Have SHADE//AGENT explain why today's trades were blocked"
2. "Let The Architect summarize the system's performance and recommendations"
3. "Generate The Banker's formal notice about the AAVE debt situation"

---

*Pipeline generated by SovereignShadow II*
*Upload this file to NotebookLM and start generating!*
"""

        with open(output_file, 'w') as f:
            f.write(package)

        print(f"  ✅ Package saved: {output_file.name}")

        return output_file

    def open_notebooklm(self):
        """Open NotebookLM in browser"""
        print("\n[4/4] Opening NotebookLM...")
        webbrowser.open(self.NOTEBOOKLM_URL)
        print(f"  ✅ Opened: {self.NOTEBOOKLM_URL}")

    def run_pipeline(self, emotion: str = "neutral", intensity: int = 5, open_browser: bool = False) -> Path:
        """
        Run full pipeline:
        1. Refresh live data
        2. Generate briefing
        3. Create NotebookLM package
        4. Optionally open browser
        """
        print("=" * 60)
        print("NOTEBOOKLM PIPELINE - SOVEREIGN SHADOW COUNCIL")
        print("=" * 60)

        # Step 1: Refresh data
        self.refresh_live_data()

        # Step 2: Generate briefing
        # Reload briefing generator to pick up new data
        self.briefing_generator = BriefingGenerator()
        briefing = self.generate_briefing(emotion, intensity)

        # Step 3: Create package
        package_path = self.create_notebooklm_package(briefing)

        # Step 4: Open browser if requested
        if open_browser:
            self.open_notebooklm()

        # Summary
        print("\n" + "=" * 60)
        print("PIPELINE COMPLETE")
        print("=" * 60)
        print(f"\nPackage ready: {package_path}")
        print(f"\nNext steps:")
        print(f"  1. Go to {self.NOTEBOOKLM_URL}")
        print(f"  2. Create new notebook or open existing")
        print(f"  3. Upload: {package_path.name}")
        print(f"  4. Use the prompts in the package to generate podcasts")
        print("=" * 60)

        return package_path


def main():
    import argparse

    parser = argparse.ArgumentParser(description='NotebookLM Pipeline')
    parser.add_argument('--emotion', default='neutral', help='Current emotion state')
    parser.add_argument('--intensity', type=int, default=5, help='Emotion intensity 1-10')
    parser.add_argument('--open', action='store_true', help='Open NotebookLM in browser')

    args = parser.parse_args()

    pipeline = NotebookLMPipeline()
    pipeline.run_pipeline(
        emotion=args.emotion,
        intensity=args.intensity,
        open_browser=args.open
    )


if __name__ == "__main__":
    main()
