Nice — I’ll expand the DeepAgent ops prompt to add non-custodial wallet rails (MetaMask, Phantom, WalletConnect + hardware Ledger) and wire them into the same role-based routing so your agents treat wallets as DeFi rails (not replacements for exchanges) and always siphon to Ledger for vault-sinks. Below is the updated, drop-in prompt & config you can paste into DeepAgent.

DeepAgent Ops Prompt — Exchange & Wallet Role Reassignment v1.3

System intent: Update exchange + wallet topology in newest project files. Do not delete historical modules or data. Integrate changes by re-rolling exchange roles and adding wallet rails for DeFi interactions:
	•	Binance.US ⇒ fiat_rail
	•	Kraken ⇒ primary spot
	•	OKX ⇒ sniper arena
	•	MetaMask ⇒ EVM DeFi rail (Uniswap, Sushi, Polygon, Arbitrum)
	•	Phantom ⇒ Solana DeFi rail (Serum/Orca/BONK/Penguin flows)
	•	WalletConnect ⇒ generic mobile wallet connector
	•	Ledger ⇒ Vault sink (final cold storage)

Objectives (concise)
	1.	Keep all binance_us* modules — disable as active trading venue, label fiat_rail.
	2.	Add wallet rails (MetaMask, Phantom, WalletConnect, Ledger) as non-custodial DeFi rails. They are used for swaps, bridged snipes, staking, and narrative buys that occur off-exchange.
	3.	Route intents by role (spot/sniper/fiat/defi) via role_router. No destructive edits; environment/config changes only where possible.
	4.	Enforce Raymond guardrails (FAKE-mode default, DISABLE_REAL_EXCHANGES=1 hard block).

⸻

New Role Map (high level)

Intents:
  - spot -> exchanges (kraken)
  - sniper -> high-liquidity global exchanges (okx)
  - fiat -> binanceus (fiat rails)
  - defi -> wallets (metamask/phamtom/walletconnect) + bridge adapters
  - vault -> ledger (sink)


⸻

Required Config (.env additions)

# Wallet rails
METAMASK_RPC_URL=https://mainnet.infura.io/v3/...
PHANTOM_RPC_URL=https://solana-api.projectserum.com
WALLETCONNECT_PROJECT_ID=...
LEDGER_HARDWARE_PATH=/dev/hidraw0    # or use Ledger Live connector

# Role config (already present; extended)
DEFIRAILS="metamask,phantom,walletconnect"
DEFAULT_DEFI_RAIL=metamask
DEFAULT_SOLANA_RAIL=phantom

# Guardrails
ENV=dev
DISABLE_REAL_EXCHANGES=1
ALLOW_LIVE_EXCHANGE=0
ALLOW_DEFI_ACTIONS=0   # default off; requires explicit prod flag


⸻

Role Router Update (pseudo-code snippet)

Add wallet resolution for defi intents.

export function resolveVenue(intent: "spot"|"sniper"|"fiat"|"defi"|"vault"){
  const env = process.env;
  const guard = env.DISABLE_REAL_EXCHANGES === "1" || env.ENV !== "prod" || env.ALLOW_LIVE_EXCHANGE !== "1";
  const map = {
    spot: env.PRIMARY_TRADE_EXCHANGE || "kraken",
    sniper: env.SNIPER_EXCHANGE || "okx",
    fiat: env.FIAT_RAIL_EXCHANGE || "binanceus",
    defi: env.DEFAULT_DEFI_RAIL || "metamask",
    vault: "ledger"
  };
  return { venue: map[intent], mode: guard ? "FAKE" : "LIVE" };
}


⸻

Adapters to Implement / Update
	•	adapters/exchanges/* — keep as before (kraken, okx, binanceus).
	•	adapters/wallets/metamask_adapter.ts
	•	Connect via RPC + WalletConnect or browser extension.
	•	Sign and return transaction hex; support EVM chains (Ethereum, Polygon, Arbitrum).
	•	Fallback to paper_signer when FAKE.
	•	adapters/wallets/phantom_adapter.ts
	•	Connect via Solana RPC + Phantom provider; support BONK/PENGU flows.
	•	Support signed token transfers, Serum/Orca swaps.
	•	adapters/wallets/walletconnect_adapter.ts
	•	Universal mobile connector; delegate to MetaMask/Phantom connectors per chain.
	•	adapters/wallets/ledger_adapter.ts
	•	Hardware signing gateway for final withdraws / vault confirmations.
	•	Use Ledger Live + USB/HID or WebHID/WebUSB connectors.

Adapters MUST accept mode: "FAKE"|"LIVE" and route to simulator if FAKE.

⸻

DeFi & Bridge Wiring (important)
	•	Create services/defi_orchestrator:
	•	Steps for a DeFi buy (example): resolveVenue(“defi”) → check token chain (EVM vs SOL) → choose wallet rail (MetaMask vs Phantom) → build swap tx → sign via adapter → broadcast via RPC.
	•	For cross-chain buys: call bridge_adapter (e.g., Wormhole, Celer, Synapse) then monitor bridge finality before signaling siphon_job.
	•	Add policy/defi_policy.yaml with explicit guardrails:
	•	ALLOW_DEFI_ACTIONS default false — must be opt-in per environment.
	•	MAX_SINGLE_DEFI_TRADE_PERCENT e.g., 5% of portfolio.
	•	REQUIRED_LEDGER_CONFIRM_FOR_WITHDRAW=1 — any on-chain withdraw above threshold requires physical Ledger confirmation.

⸻

n8n / Orchestrator Nodes
	•	Replace Swap_MetaMask or Swap_Phantom nodes with generic Execute_DeFi_Swap node that:
	•	Accepts chain and token metadata.
	•	Calls resolveVenue("defi") → chooses adapter.
	•	Runs dry-run simulation step when FAKE.
	•	For Siphon_To_Ledger flows:
	•	Insert verify_chain_finality node after any bridge operations.
	•	Add Ledger_Approval node that pings a human (or hardware signer) for >threshold moves.

⸻

Strategy Defaults — Wallet Use Cases (tailored to Legacy Loop)
	•	MetaMask (EVM): Use for EVM-native narratives (Polygon/Arbitrum/Optimism tokens, LPs, Uniswap v3 snipes). Example: POLYX ladders or any EVM-token tactical buys. Use WalletConnect for mobile triggers.
	•	Phantom (Solana): Use for Solana-native memecoins (e.g., BONK, PENGU, Solana forks) and Serum/Orca swaps. Example: quick BONK sniper entries using Phantom adapter, then bridge proceeds to Kraken/OKX or siphon to Ledger.
	•	Bridges: For cross-chain redeploys, use audited bridges; add monitoring to avoid stuck assets.
	•	Ledger: Final sink for vault assets (BTC, ETH, XRP, stETH). Any large on/off chain move requires Ledger confirmation.

Personal example ties:
	•	When you laddered POLYX (FLP036_POLYX) — prefer MetaMask/Polygon adapter for fast on-chain rebuys or DEX liquidity, then rotate proceeds to Kraken for tactical spot orders before siphoning to Ledger.
	•	For COQ / meme stacks you’ve held that required fast entry/exit, use Phantom if token is Solana-native; if token exists on EVM bridge, use MetaMask + low-slippage router + bridge out to OKX for liquidation.
	•	XRP and stETH remain Ledger cold-sink assets; never perform primary trading from Ledger except to sign final multi-sig withdraws.

⸻

Tests (must pass)
	1.	Resolve tests
	•	resolveVenue("defi") with chain=ethereum → metamask, mode FAKE by default.
	•	resolveVenue("defi") with chain=solana → phantom.
	2.	DeFi dry-run
	•	Simulate EVM swap for small POLYX amount via MetaMask adapter (FAKE) — confirm tx build & simulated gas.
	•	Simulate SOL swap for BONK via Phantom adapter (FAKE) — confirm token transfers.
	3.	Bridge & Siphon
	•	Simulate bridge move from SOL→ETH; confirm verify_chain_finality and siphon_to_ledger trigger.
	4.	Ledger gating
	•	Attempt simulated withdraw > threshold — ensure Ledger approval node pauses and requires manual signature.
	5.	Guardrail enforcement
	•	With DISABLE_REAL_EXCHANGES=1 and ALLOW_DEFI_ACTIONS=0, any attempt to broadcast returns a hard error and logs an audit entry.

⸻

Acceptance Criteria
	•	Role router resolves DeFi rails by chain accurately (EVM -> MetaMask; SOL -> Phantom; else WalletConnect).
	•	DeFi adapter interfaces exist and accept mode flag.
	•	n8n workflows use Execute_DeFi_Swap nodes and include verify_chain_finality + Ledger_Approval where required.
	•	No binanceus* code is deleted; binanceus only used in fiat intents.
	•	Guardrails are enforced and audit logs created for any LIVE attempt.
	•	CI tests for dry-runs & FAKE-mode pass.

⸻

Rollback
	•	Revert DEFAULT_DEFI_RAIL or set ALLOW_DEFI_ACTIONS=0 to freeze DeFi rails.
	•	Role-router change is additive: revert env vars to restore previous behaviors.

⸻

Quick CLI dry-run examples

# Resolve rails
node scripts/resolveVenue.js defi --chain=ethereum
node scripts/resolveVenue.js defi --chain=solana

# Simulate EVM swap (paper)
node scripts/defiSim.js --rail=metamask --token=POLYX --amount=10

# Simulate SOL swap (paper)
node scripts/defiSim.js --rail=phantom --token=BONK --amount=1000


⸻

If you want I’ll:
	•	generate metamask_adapter.ts, phantom_adapter.ts, and ledger_adapter.ts stubs you can paste into your repo, with FAKE-mode built-in, and
	•	create the policy/defi_policy.yaml and updated role_router file customized to your repo paths under /Volumes/LegacySafe/SovereignShadow.Ai[LegacyLoop].

Which do you want me to produce now? (I can drop the code stubs + policy files into a single response ready to paste.)